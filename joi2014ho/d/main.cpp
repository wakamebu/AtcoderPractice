/*
一辺 N 本の正三角形の形に釘を並べて刺してある．
上から a 行目には a 本の釘が並んでいる．そのうち左から b 本目の釘を (a, b) で表す．

3 本の釘(a, b), (a + x, b), (a + x, b + x) を頂点とする正三角形を「良い三角形」と呼ぶ。
M 本の輪ゴムによって、釘 (A[i], B[i]), (A[i] + X[i], B[i]), (A[i] + X[i], B[i] + X[i]) を囲む。
一本以上の輪ゴムによって囲まれている釘の数は何本か。

2 <= N <= 5000
1 <= M <= 5 x 10^5 
1 <= B[i] <= A[i] <= N 
1 <= X[i] <= N − A[i])
*/

/*
三角形座標を二次元平面と捉え直して、いもす法を行う。

例えば (a, b, x=4) が指定されたとき。(a が縦の座標指定, b が横の座標指定)
左上の頂点を(a, b) としてとき、二次元座標ではこんな風に表される。
 1 0 0 0 0 0
 1 1 0 0 0 0
 1 1 1 0 0 0
 1 1 1 1 0 0
 0 0 0 0 0 0
 0 0 0 0 0 0

まず最終的に、下図のような形にして、上から下への数え上げをすればよい。
 +1  0  0  0  0  0
  p +1  0  0  0  0
  p  p +1  0  0  0
  p  p  p +1  0  0
 -1 -1 -1 -1  0  0
  0  0  0  0  0  0 (最終図)
図の +1 と -1 がメモの必要な場所。 p は数え上げによって 1 になる数。

最終図を作るには、下図のような形にして、左上から右下へ数え上げをすればよい。
 +1  0  0  0  0  0
  0  p  0  0  0  0
  0  0  p  0  0  0
  0  0  0  p  0  0
 -1 -1 -1 -1 -1  0
  0 +1 +1 +1 +1  0 (ひとつ手前の図)
斜め部分の +1 は単純なメモで構築できるが、下行の -1 を左上から右下へ数え上げしたとき、打消しが必要なので、-1 のひとつ下行に +1 の行が必要となった。

ひとつ手前の図を作るには、下図のような形にして、左から右へ数え上げをすればよい。
 +1 -1  0  0  0  0
  0  0  0  0  0  0
  0  0  0  0  0  0
  0  0  0  0  0  0
 -1  0  0  0  0 +1
  0 +1  0  0  0 -1

つまり、(a, b, x=4) が指定されたとき、
    +1 のメモ   ：  (a, b), (a+x+1, b+x+2), (a+x+2, b+1) の3箇所
    -1 のメモ   ：  (a, b+1), (a+x+1, b), (a+x+2, b+x+2) の3箇所
をメモして、
    step1. 左から右へ数え上げ
    step2. 左上から右下へ数え上げ
    step3. 上から下への数え上げ
の順で実行すれば、目標の三角形部分が +1 で埋めつくされた状態になる。

a+x+2 にメモを入れたいので、二次元平面の大きさは縦横ともに N+2 にしておく.
*/


#include <bits/stdc++.h>
using namespace std;
 
int main() {
    int N, M;
    cin >> N >> M;

    // いもす法に使うメモ用コンテナと、数え上げに使用するコンテナ。
    // 問題文は (1, 1) スタートなので、(0, 0) の行・列を追加したい　→ コンテナ数を N+1 にする。
    // 更に a+x+2 や b+x+2 にメモをしたい → 更にコンテナ数を +2 する。
    vector<vector<int>> memo(N+3, vector<int>(N+3, 0));;      // メモ用。コンテナ数は N+3 * N+3. 初期値は 0 で埋めておく
    vector<vector<int>> neil(N+3, vector<int>(N+3, 0));;      // 数え上げに使用。コンテナ数は N+3 * N+3. 初期値は 0 で埋めておく

    // M 件の輪ゴムの囲い方の入力とメモ
    for (int i = 0; i < M; i++){
        int a, b, x;
        cin >> a >> b >> x;

        // +1 でメモする位置は 3 箇所
        memo.at(a).at(b)++;
        memo.at(a + x + 1).at(b + x + 2)++;
        memo.at(a + x + 2).at(b + 1)++;

        //  -1 でメモする位置は 3 箇所
        memo.at(a).at(b + 1)--;
        memo.at(a + x + 1).at(b)--;
        memo.at(a + x + 2).at(b + x + 2)--;
    }

    // 数え上げの実行
    // 問題文とは無関係な (0, 0) の行・列を追加してあり、しかも初期値 0 で埋めてあるので、それを初項に使用する。

    // step1. 左から右への数え上げ
    for (int i = 1; i < N+3; i++){      // i が縦の座標
        for (int j = 1; j < N+3; j++){  // j が横の座標
            neil.at(i).at(j) = neil.at(i).at(j-1) + memo.at(i).at(j);  // step1 だけメモも参照。「左から右」なので、参照するマスは (i, j-1)
            
        }
    }

    // step2. 左上から右下への数え上げ
    for (int i = 1; i < N+3; i++){
        for (int j = 1; j < N+3; j++){
            neil.at(i).at(j) += neil.at(i-1).at(j-1);  // 「左上から右下」なので、参照するマスは (i-1, j-1) と自分自身
        }
    }

    // step3. 上から下への数え上げ
    for (int i = 1; i < N+3; i++){
        for (int j = 1; j < N+3; j++){
            neil.at(i).at(j) += neil.at(i-1).at(j);  // 「上から下」なので、参照するマスは (i-1, j) と自分自身
        }
    }

    // 数え上げ完了後、釘が +1 以上の値になっていたら答えにカウントする
    int ans = 0; 
    for (int i = 1; i < N+3; i++){
        for (int j = 1; j < N+3; j++){

            

            if (neil.at(i).at(j) > 0){  // 頂点 (i, j) の釘が、+1 以上の値になっていたら答えにカウントする
               ans++;
            }
        }
    }

    cout << ans << endl;
    return 0;
}

